### 1. Delegate pattern 에 대해 설명해주세요.
- 지금까지 이해하기로 Delegate pattern은 구조체 또는 클래스에서 역할을 다른 객체로 이양할 수 있는 디자인 패턴이다.
Delegate의 역할은 어플 내에서 발생하는 알림, 안내를 인지하고 대응할 수 있도록 돕는데, 객체1이 가지고 있던 책임 또는 역할을 객체2에게 넘김으로써 객체1은 해당 업무에 대해서는 별도로 생각할 필요가 없다는 점이다.
Delegate Pattern을 통해 한 파일 또는 객체에서 처리해야하는 일들을 덜어줄 수 있다는 점이 가장 큰 장점으로 와 닿는다.

### 2. 탈출 클로저(Escaping Closure)에 대해 설명해주세요.
- 탈출 클로저는 간단하게 정리하면 함수를 외부로 던져 - 해당 함수를 백그라운드에서 실행하는 개념과 비슷하다고 볼 수 있을 것 같다.
말그대로 escaping, 탈출 할 수 있는 closure(일급 객체)라는 점인데, 개인적으로 시간이 비교적 오래걸릴 API 호출이나 데이터 사용에 있어 활용을 했다.

프로그래밍 특성상, 한 줄에서 실행되는 코드는 해당 함수가 완료되거나 데이터를 모두 받을 때까지 '해당 코드'에 머물러 있게 된다.
이 때 데이터량이 많거나 함수가 실행해야하는 과정이 많을 경우, UI가 멈춰있거나 다른 코드가 실행되지 않는 상태에 머물게 된다.

이 때 escaping Closure을 활용하면
1. 해당 함수는 다시 호출되기 전까지 메모리 상에서 존재를 한다.
2. 데이터를 100% 받을 때까지 

escaping closure은 함수의 범위를 벗어날 수 있다는 점에서 큰 장점이 있다.


//MARK: - Storage
var completionHandler: ((Int) -> Void)?

func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    self.completionHandler = handler
}

func doSomething() {
    self.getSumOf(array: [10, 5, 12]) { [weak self](sum) in
        print(sum)
    }
}


//MARK: - Asynchronous Execution
func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    Globals.delay(0.3, closure: {
        handler(sum)
    })
}

func doSomething2() {
    self.getSumOf(array: [16, 756, 442,6]) { [weak self](sum) in
        print(sum)
    }
}

### Question
-> Why did Apple change closure's default status to nonEscaping?
- Initially closures were intended to escape their parameters. It was their original intention up to Swift 2.x.
However, with additional memory usage from default escaping closures, Apple seemed to have changed their idea to selectively choose which closures to be @escaping.

-> How is Escaping closure taking up more memory compared to nonEscaping?
클로저의 내부 구현 모습을 보면 아래와 같다고 한다.
struct Closure { 
    var functionPointer: UnsafeRawPointer
    var closureContext: AnyObject?
}

이해가 잘 안되지만, 지금까지 읽었을 때는 두 개의 포인터가 존재하며, 하나의 포인터는 클로저를 활용하는 함수를, 다른 포인터는 객체를 가르키고 있다고 한다.
escaping 클로저가 capture list를 heap에 저장하여 '메모리 자체에 객체와 값을 표시하고 있는 반면, nonEscaping은 해당 함수 범위 안에서만 존재하기 때문에 heap에 저장되는 값이 없다.'
그렇기에 escaping closure은 메모리를 차지하는 반면 nonEscaping은 없다!