### 1. Delegate pattern 에 대해 설명해주세요.
- 지금까지 이해하기로 Delegate pattern은 구조체 또는 클래스에서 역할을 다른 객체로 이양할 수 있는 디자인 패턴이다.
Delegate의 역할은 어플 내에서 발생하는 알림, 안내를 인지하고 대응할 수 있도록 돕는데, 객체1이 가지고 있던 책임 또는 역할을 객체2에게 넘김으로써 객체1은 해당 업무에 대해서는 별도로 생각할 필요가 없다는 점이다.
Delegate Pattern을 통해 한 파일 또는 객체에서 처리해야하는 일들을 덜어줄 수 있다는 점이 가장 큰 장점으로 와 닿는다.

### 2. 탈출 클로저(Escaping Closure)에 대해 설명해주세요.
- 탈출 클로저는 간단하게 정리하면 함수를 외부로 던져 - 해당 함수를 백그라운드에서 실행하는 개념과 비슷하다고 볼 수 있을 것 같다.
말그대로 escaping, 탈출 할 수 있는 closure(일급 객체)라는 점인데, 개인적으로 시간이 비교적 오래걸릴 API 호출이나 데이터 사용에 있어 활용을 했다.

프로그래밍 특성상, 한 줄에서 실행되는 코드는 해당 함수가 완료되거나 데이터를 모두 받을 때까지 '해당 코드'에 머물러 있게 된다.
이 때 데이터량이 많거나 함수가 실행해야하는 과정이 많을 경우, UI가 멈춰있거나 다른 코드가 실행되지 않는 상태에 머물게 된다.

이 때 escaping Closure을 활용하면
1. 해당 함수는 다시 호출되기 전까지 메모리 상에서 존재를 한다.
2. 데이터를 100% 받을 때까지 

escaping closure은 함수의 범위를 벗어날 수 있다는 점에서 큰 장점이 있다.


//MARK: - Storage
```swift
var completionHandler: ((Int) -> Void)?

func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    self.completionHandler = handler
}

func doSomething() {
    self.getSumOf(array: [10, 5, 12]) { [weak self](sum) in
        print(sum)
    }
}
```


//MARK: - Asynchronous Execution
```swift
func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    Globals.delay(0.3, closure: {
        handler(sum)
    })
}

func doSomething2() {
    self.getSumOf(array: [16, 756, 442,6]) { [weak self](sum) in
        print(sum)
    }
}
```

### Question
-> Why did Apple change closure's default status to nonEscaping?
- Initially closures were intended to escape their parameters. It was their original intention up to Swift 2.x.
However, with additional memory usage from default escaping closures, Apple seemed to have changed their idea to selectively choose which closures to be @escaping.

-> How is Escaping closure taking up more memory compared to nonEscaping?
클로저의 내부 구현 모습을 보면 아래와 같다고 한다.
struct Closure { 
    var functionPointer: UnsafeRawPointer
    var closureContext: AnyObject?
}

이해가 잘 안되지만, 지금까지 읽었을 때는 두 개의 포인터가 존재하며, 하나의 포인터는 클로저를 활용하는 함수를, 다른 포인터는 객체를 가르키고 있다고 한다.
escaping 클로저가 capture list를 heap에 저장하여 '메모리 자체에 객체와 값을 표시하고 있는 반면, nonEscaping은 해당 함수 범위 안에서만 존재하기 때문에 heap에 저장되는 값이 없다.'
그렇기에 escaping closure은 메모리를 차지하는 반면 nonEscaping은 없다!

-> Why closures require self?
1. self is only required when calling a property or a method from a closure 
or
2. to differentiate property names within your code.
It's an offspring from Objective-C, provides information to developers that it's intended to access a property rather than a local variable.

#### 2.1 non-escaping vs escaping closure
클로저는 일급 객체로 코드 전반적으로 (함수, 객체) 활용될 수 있다.
클로저는 엄밀히 말하면 두가지가 존재한다고 볼 수 있다.
non escaping과 escaping인 경우이다.
non escaping은 우리가 특정 함수 또는 값이 곧바로 돌아온다는 가정이 된다면 사용한다.
(일반적으로 사용하는 closure 모두 non-escaping이기는 하다!)

```swift
Non-Escaping 클로저

private let logoView = UIImageView().then {
    let image = UIImage(named: "MainIcon")
    $0.image = image
    $0.contentMode = .scaleAspectFill
}

non-escaping일 경우, 함수의 범위를 벗어나거나 클로저 범위 밖에서 존재하지 못한다.
메모리에 별도로 저장되지 않고 해당 코드가 실행된 이후 곧바로 종료된다.
```
___

```swift
Escaping 클로저

func getReviewData(completion: @escaping (Result<[Review], Error>) -> Void) {
    fetchCollectionData(from: "reviews", objectType: Review.self, completion: completion)
}

반대로 escaping closure는 위에 서술한대로 해당 범위를 뛰어 넘어 존재할 수 있게 된다.

``````

___

#### 2.2 @autoclosure
함수 속에 던져지는 값을 자동으로 closure로 만들도록 돕는다 한다.
*이해가 안되는 부분은 애초에 closure 개념으로 코드를 짜고 있는 과정에서 왜 필요한건지 모르겠다

func animate(_ animation: @autoclosure @escaping () -> Void, duration: TimeInterval = 0.25) {
    UIView.animate(withDuration: duration, animations: animation)
}

### 3. **setNeedsLayout과 setNeedsDisplay의 차이에 대해서 설명해주세요.**
setNeedsLayout과 setNeedsDisplay는 둘다 drawing cycle에 맞춰 화면을 업데이트한다.
즉, 화면을 즉시 업데이트 하는 메서드가 아니라는 점인다.

공식문서에 따르면 setNeedsLayout은 뷰의 서브뷰의 layout을 다시 잡고 싶다면 어플 메인 쓰레드에 호출하라고 한다.
setNeedsDisplay는 시스템에 뷰의 콘텐츠가 다시 그려져야 한다는 점을 알려야할 때 사용해라고 하는데, 어떤 차이가있을까!

먼저 layout은 subView의 layout을 다시 잡아야 하는 상황이 필요하다.
예상이 잘 안되지만 화면의 크기가 바뀌었다고 보자.
만일 view 속에 여러 UIComponent들을 넣어두고 constraint를 잡아두었다면 - 새로운 화면에서는 원래 의도했던대로 보이지 않을 것이다.
이는 view의 layout이 다르게 변하면서 그럴 것이다!


반대로 setNeedsDisplay는 예상하기로 아래와 같이 snapKit에서 remakeConstraint 같은 역할과 비슷해보인다.
view에 담긴 무언가의 변화가 발생하며 view를 다시 그리는 상황에서 setNeedsDisplay를 실행하는 것으로 보인다.

```swift
func setPwTextView() {
        if doublecheckEmailView.isHidden {
            passwordStackView.snp.makeConstraints {
                $0.top.equalTo(registerStackView.snp.bottom).offset(10)
                $0.leading.trailing.equalToSuperview().inset(20)
            }
        } else {
            // 해당 역할과 동일해보인다.
            passwordStackView.snp.remakeConstraints {
                $0.top.equalTo(doublecheckEmailView.snp.bottom).offset(10)
                $0.leading.trailing.equalToSuperview().inset(20)
            }
        }
        self.layoutIfNeeded()
    }
```

### 4. **URLSession을 이용해서 서버에 요청을 보내데이터를 받기 위해 어떤 과정을 거치는지 설명해주세요. (Get 요청)**
### 5. **MVC와 MVVM의 차이점에 대해서 설명해주세요. (MVVM 중심으로)**

MVC와 MVVM은 코드를 어느정도의 규칙과 구조를 따라 짤 수 있도록 돕는 디자인 패턴이다.
마구잡이로 코드를 길~게 쓰는 것보다 읽기 편하고 코드 재활용 가능성이 높아지기 때문에 긍정적인 부분이다.

MVC와 MVVM의 가장 큰 차이점은 흐름의 변화로 이해된다.
MVC는 controller로부터 사용자 입력을 받는 반면, MVVM은 View에서 입력을 받는다. (entry point)
따라서 MVC는 Controller > Model > View의 흐름으로 View가 어플 내부의 비즈니스 데이터의 현황을 파악하고 이에 맞게 업데이트를 한다.
반면, MVVM은 View > ViewModel > Model 흐름으로 이어진다. View는 ViewModel이 시키는 일만 따를 뿐, 비즈니스 데이터가 어떻게 된지는 좀 더 모른다는 점이다.

이렇게 되면서 MVC는 spaghetti 코드를 정리해주는 디자인 패턴으로 인식되었지만
Controller 역할을 맡은 파일에 로직과 UIComponent가 몰리며 점점 무거워지자
MVVM을 통해 한번 더 잘게 코드를 쪼겔 수 있는 디자인 패턴을 사용하게 된 것이다.

### 6. **Grand Central Dispatch (GCD)와 Operation Queue의 차이점은 무엇인가요?**
**코드를 동시다발적으로 실행하기 위해 사용하는 API이다.**

이름만 들었을 때 GCD는 전체 Thread의 Dispatch(분배)를 담당하는 중앙 관리 시스템으로 생각했다.
대체로 비슷한 역할을 맞은 것으로 이해하는데, 어플에서 실행하는 과제들을 알맞는 수준의 core를 분배해서 수행할 수 있도록 돕는 과정이었다!

GCD는 시스템이 동시다발적으로 어플을 효율적으로 실행할 수 있도록 도와주는 프레임워크다.
멀티코어 장치에서 concurrent code execution을 도와주는데, 가능한 이유는 GCD (GrandCentral Dispatch)에 language feature, runtime Libraries, system enhancement가 있기 때문이라고 한다.
어플이 실행되거나 특정 역할을 수행할 때 알맞는 정도의 core를 효율적으로 사용할 수 있도록 조절을 해준다는 점.

####Q. DispatchQueue는 무엇일까?
FIFO(First In First Out) queue로 어플에서 실행하고자 하는 task를 입력받아 실행하는 대기열 같은 존재. - FIFO이지만, 순차적으로 일이 끝날 것이라고 보장하지 않는다.
즉, 먼저 입력된 사용자 interaction이 먼저 수행되도록 queue열에 담는 다는 것인데, 해당 task들은 동시다발적으로 실행이 되거나 순차적으로 실행된다고 한다.
한가지 특이점은 main Dispatch Queue로 들어온 task들은 어느 쓰레드를 사용할지에 대한 확신을 내리지 못한다고 한다. (즉, main으로 할당해도 main이 아닐수가 있다?)
쉽고 빠르게 쓸 수 있다는 점이 가장 큰 장점인 GCD는 queue에 task가 들어간 이상 취소를 할 수 없다.
더불어 실행을 멈추거나 재실행할 수 없다는 단점이 존재한다.
이로 인해 GCD를 활용하면 비교적 제한이 많다는 지적이 나오는데 이를 보완하는 구조가 Operation Queue이다.

####Q. Operation Queue는 무엇일까?
DispatchQueue 위에 쌓여 만들어진 Queue로 한 단계 더 발전된 모습을 보여준다.
GCD와 달리 Operation Queue는 Queue 중간에 멈추거나 재실행, 제거를 할 수 있기에 더 자유자재로 queue를 제어할 수 있다.

다중 쓰레딩, 병렬 처리
비동기 동기 질문, serial queue, concurrent
main과 global, UI는 어떤 쓰레드

Q. concurrent와 serial는 어떤 차이로 진행되는걸까?
global, main을 사용하느냐에 따라 다르게 적용할 수 있다.
global = concurrent, main = serial queue인 셈.

### 7. **SwiftUI와 UIKit의 차이점은 무엇이며, 어떤 상황에서 어떤 프레임워크를 사용해야 하나요?**
### 8. **고차함수(`map`, `filter`, `reduce`)에 대해서 설명해주세요.**
### 9. **ARC(ARC: Automatic Reference Counting)에 대해 설명해주세요.**
### 10. **참조에 대해서 설명해주세요. (strong, weak, unowned)**
### 11. **강한 순환 참조가 언제 발생하는지와 어떻게 해결할 수 있는지 설명해주세요.**
### 12. **UINavigationController 의 역할이 무엇인지 설명해주세요.**
### 13. **shallow copy와 deep copy의 차이점을 설명해주세요.**


### 참고
- [6. GCD와 Operation Queue 차이](https://www.linkedin.com/advice/1/what-benefits-drawbacks-using-gcd-vs-operationqueue)
