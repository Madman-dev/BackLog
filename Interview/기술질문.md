### 1. Delegate pattern 에 대해 설명해주세요.
- 지금까지 이해하기로 Delegate pattern은 구조체 또는 클래스에서 역할을 다른 객체로 이양할 수 있는 디자인 패턴이다.
Delegate의 역할은 어플 내에서 발생하는 알림, 안내를 인지하고 대응할 수 있도록 돕는데, 객체1이 가지고 있던 책임 또는 역할을 객체2에게 넘김으로써 객체1은 해당 업무에 대해서는 별도로 생각할 필요가 없다는 점이다.
Delegate Pattern을 통해 한 파일 또는 객체에서 처리해야하는 일들을 덜어줄 수 있다는 점이 가장 큰 장점으로 와 닿는다.

### 2. 탈출 클로저(Escaping Closure)에 대해 설명해주세요.
- 탈출 클로저는 간단하게 정리하면 함수를 외부로 던져 - 해당 함수를 백그라운드에서 실행하는 개념과 비슷하다고 볼 수 있을 것 같다.
말그대로 escaping, 탈출 할 수 있는 closure(일급 객체)라는 점인데, 개인적으로 시간이 비교적 오래걸릴 API 호출이나 데이터 사용에 있어 활용을 했다.

프로그래밍 특성상, 한 줄에서 실행되는 코드는 해당 함수가 완료되거나 데이터를 모두 받을 때까지 '해당 코드'에 머물러 있게 된다.
이 때 데이터량이 많거나 함수가 실행해야하는 과정이 많을 경우, UI가 멈춰있거나 다른 코드가 실행되지 않는 상태에 머물게 된다.

이 때 escaping Closure을 활용하면
1. 해당 함수는 다시 호출되기 전까지 메모리 상에서 존재를 한다.
2. 데이터를 100% 받을 때까지 

escaping closure은 함수의 범위를 벗어날 수 있다는 점에서 큰 장점이 있다.


//MARK: - Storage
```swift
var completionHandler: ((Int) -> Void)?

func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    self.completionHandler = handler
}

func doSomething() {
    self.getSumOf(array: [10, 5, 12]) { [weak self](sum) in
        print(sum)
    }
}
```


//MARK: - Asynchronous Execution
```swift
func getSumOf(array: [Int], handler: @escaping ((Int) -> Void)) {
    var sum: Int = 0
    for value in array {
        sum += value
    }

    Globals.delay(0.3, closure: {
        handler(sum)
    })
}

func doSomething2() {
    self.getSumOf(array: [16, 756, 442,6]) { [weak self](sum) in
        print(sum)
    }
}
```

### Question
-> Why did Apple change closure's default status to nonEscaping?
- Initially closures were intended to escape their parameters. It was their original intention up to Swift 2.x.
However, with additional memory usage from default escaping closures, Apple seemed to have changed their idea to selectively choose which closures to be @escaping.

-> How is Escaping closure taking up more memory compared to nonEscaping?
클로저의 내부 구현 모습을 보면 아래와 같다고 한다.
struct Closure { 
    var functionPointer: UnsafeRawPointer
    var closureContext: AnyObject?
}

이해가 잘 안되지만, 지금까지 읽었을 때는 두 개의 포인터가 존재하며, 하나의 포인터는 클로저를 활용하는 함수를, 다른 포인터는 객체를 가르키고 있다고 한다.
escaping 클로저가 capture list를 heap에 저장하여 '메모리 자체에 객체와 값을 표시하고 있는 반면, nonEscaping은 해당 함수 범위 안에서만 존재하기 때문에 heap에 저장되는 값이 없다.'
그렇기에 escaping closure은 메모리를 차지하는 반면 nonEscaping은 없다!

-> Why closures require self?
1. self is only required when calling a property or a method from a closure 
or
2. to differentiate property names within your code.
It's an offspring from Objective-C, provides information to developers that it's intended to access a property rather than a local variable.

#### 2.1 non-escaping vs escaping closure
클로저는 일급 객체로 코드 전반적으로 (함수, 객체) 활용될 수 있다.
클로저는 엄밀히 말하면 두가지가 존재한다고 볼 수 있다.
non escaping과 escaping인 경우이다.
non escaping은 우리가 특정 함수 또는 값이 곧바로 돌아온다는 가정이 된다면 사용한다.
(일반적으로 사용하는 closure 모두 non-escaping이기는 하다!)

```swift
Non-Escaping 클로저

private let logoView = UIImageView().then {
    let image = UIImage(named: "MainIcon")
    $0.image = image
    $0.contentMode = .scaleAspectFill
}

non-escaping일 경우, 함수의 범위를 벗어나거나 클로저 범위 밖에서 존재하지 못한다.
메모리에 별도로 저장되지 않고 해당 코드가 실행된 이후 곧바로 종료된다.
```
___

```swift
Escaping 클로저

func getReviewData(completion: @escaping (Result<[Review], Error>) -> Void) {
    fetchCollectionData(from: "reviews", objectType: Review.self, completion: completion)
}

반대로 escaping closure는 위에 서술한대로 해당 범위를 뛰어 넘어 존재할 수 있게 된다.

``````

___

#### 2.2 @autoclosure
함수 속에 던져지는 값을 자동으로 closure로 만들도록 돕는다 한다.
*이해가 안되는 부분은 애초에 closure 개념으로 코드를 짜고 있는 과정에서 왜 필요한건지 모르겠다

func animate(_ animation: @autoclosure @escaping () -> Void, duration: TimeInterval = 0.25) {
    UIView.animate(withDuration: duration, animations: animation)
}

### 3. **setNeedsLayout과 setNeedsDisplay의 차이에 대해서 설명해주세요.**
setNeedsLayout과 setNeedsDisplay는 둘다 drawing cycle에 맞춰 화면을 업데이트한다.
즉, 화면을 즉시 업데이트 하는 메서드가 아니라는 점인다.

공식문서에 따르면 setNeedsLayout은 뷰의 서브뷰의 layout을 다시 잡고 싶다면 어플 메인 쓰레드에 호출하라고 한다.
setNeedsDisplay는 시스템에 뷰의 콘텐츠가 다시 그려져야 한다는 점을 알려야할 때 사용해라고 하는데, 어떤 차이가있을까!

먼저 layout은 subView의 layout을 다시 잡아야 하는 상황이 필요하다.
예상이 잘 안되지만 화면의 크기가 바뀌었다고 보자.
만일 view 속에 여러 UIComponent들을 넣어두고 constraint를 잡아두었다면 - 새로운 화면에서는 원래 의도했던대로 보이지 않을 것이다.
이는 view의 layout이 다르게 변하면서 그럴 것이다!


반대로 setNeedsDisplay는 예상하기로 아래와 같이 snapKit에서 remakeConstraint 같은 역할과 비슷해보인다.
view에 담긴 무언가의 변화가 발생하며 view를 다시 그리는 상황에서 setNeedsDisplay를 실행하는 것으로 보인다.

```swift
func setPwTextView() {
        if doublecheckEmailView.isHidden {
            passwordStackView.snp.makeConstraints {
                $0.top.equalTo(registerStackView.snp.bottom).offset(10)
                $0.leading.trailing.equalToSuperview().inset(20)
            }
        } else {
            // 해당 역할과 동일해보인다.
            passwordStackView.snp.remakeConstraints {
                $0.top.equalTo(doublecheckEmailView.snp.bottom).offset(10)
                $0.leading.trailing.equalToSuperview().inset(20)
            }
        }
        self.layoutIfNeeded()
    }
```

### 4. **URLSession을 이용해서 서버에 요청을 보내데이터를 받기 위해 어떤 과정을 거치는지 설명해주세요. (Get 요청)**
### 5. **MVC와 MVVM의 차이점에 대해서 설명해주세요. (MVVM 중심으로)**
### 6. **Grand Central Dispatch (GCD)와 Operation Queue의 차이점은 무엇인가요?**
### 7. **SwiftUI와 UIKit의 차이점은 무엇이며, 어떤 상황에서 어떤 프레임워크를 사용해야 하나요?**
### 8. **고차함수(`map`, `filter`, `reduce`)에 대해서 설명해주세요.**
### 9. **ARC(ARC: Automatic Reference Counting)에 대해 설명해주세요.**
### 10. **참조에 대해서 설명해주세요. (strong, weak, unowned)**
### 11. **강한 순환 참조가 언제 발생하는지와 어떻게 해결할 수 있는지 설명해주세요.**
### 12. **UINavigationController 의 역할이 무엇인지 설명해주세요.**
### 13. **shallow copy와 deep copy의 차이점을 설명해주세요.**